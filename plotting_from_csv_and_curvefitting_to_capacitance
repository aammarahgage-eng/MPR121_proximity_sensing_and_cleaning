import matplotlib.pyplot as plt
import pandas as pd
import numpy as np
from scipy.optimize import curve_fit
import glob
import os
import re

directory_path = 'Nov_23_2025' #enter your directory path
file_pattern = os.path.join(directory_path, '*cm,*s.csv')
csv_files = glob.glob(file_pattern)

print(f"Found {len(csv_files)} files") #check if we're reading all the files in the folder

distances = []
avg_values = []

for filepath in csv_files:
    df = pd.read_csv(filepath)
    df.columns = ['Timestamp', 'SerialData']

    # Extract distance from filename (e.g., "10cm,5s.csv" -> 10)
    filename = os.path.basename(filepath)
    match = re.search(r'(\d+)cm', filename)

    if match:
        distance = int(match.group(1))

        # Extract only the first 10 seconds of data
        df_2s = df[df['Timestamp'] <= 10.0]

        if len(df_2s) > 0:
            # Calculate average value over those 10 seconds
            avg_value = df_2s['SerialData'].mean()

            distances.append(distance)
            avg_values.append(avg_value)

            print(f"{filename}: distance={distance}cm, avg value (0-10s)={avg_value:.2f}")

# Sort by distance for cleaner plotting
sorted_data = sorted(zip(distances, avg_values))
distances, avg_values = zip(*sorted_data)

# Plot
plt.figure(figsize=(10, 10))
plt.plot(distances, avg_values, marker='o', markersize=8, linewidth=2)
plt.xlabel('Distance From Prusa (cm)')
plt.ylabel('Average Serial Data (0-10 seconds)')
plt.title('Distance vs Sensor Reading (First 10 Seconds)')
plt.grid(True)
plt.show()


#begin curve fitting code for capacitance in a parallel plate 
distances = np.array(distances)
avg_values = np.array(avg_values)


# Define the capacitance model: C = k / d
# Where k combines all constants (ε₀, ε_r, A)
def capacitance_model(d, k):
    return k / d

# Fit the model to data
try:
    # Initial guess for k
    popt, pcov = curve_fit(capacitance_model, distances, avg_values, p0=[100]) #p0 is the value of capicatance / distance

    k_fitted = popt[0]

    # Generate smooth curve for plotting
    d_smooth = np.linspace(min(distances), max(distances), 100)
    fitted_values = capacitance_model(d_smooth, k_fitted)

    # Plot
    plt.figure(figsize=(10, 6))
    plt.scatter(distances, avg_values, s=100, label='Measured Data', color='blue', zorder=3)
    plt.plot(d_smooth, fitted_values, 'r-', linewidth=2, label=f'Fit: C = {k_fitted:.2f}/d')

    plt.xlabel('Distance (cm)')
    plt.ylabel('Sensor Reading (avg 0-10s)')
    plt.title('Capacitance vs Distance - Parallel Plate Model')
    plt.legend()
    plt.grid(True)
    plt.show()

    print(f"\nFitted parameter k = {k_fitted:.4f}")

    # Calculate R² (goodness of fit)
    residuals = avg_values - capacitance_model(distances, k_fitted)
    ss_res = np.sum(residuals ** 2)
    ss_tot = np.sum((avg_values - np.mean(avg_values)) ** 2)
    r_squared = 1 - (ss_res / ss_tot)
    print(f"R² = {r_squared:.4f}")

except Exception as e:
    print(f"Fitting failed: {e}")
